use crate::app::{App, AppMode, MessageRole};
use crate::markdown::render_markdown;
use ratatui::{
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style, Stylize},
    text::{Line, Span},
    widgets::{Block, Borders, Clear, List, ListItem, ListState, Padding, Paragraph, Wrap},
    Frame,
};

// --- OpenCode Theme Palette ---
const BG_MAIN: Color = Color::Rgb(9, 9, 9); // Deep Black
const BG_INPUT: Color = Color::Rgb(30, 30, 30); // Dark Gray for input
const FG_PRIMARY: Color = Color::Rgb(220, 220, 220); // Off-white
const FG_SECONDARY: Color = Color::Rgb(100, 100, 100); // Dimmed text
const ACCENT_ORANGE: Color = Color::Rgb(255, 158, 100); // Cursor / Highlight
const ACCENT_BLUE: Color = Color::Rgb(122, 162, 247); // Mode indicators
const BORDER_DIM: Color = Color::Rgb(40, 40, 40);

const SPINNER: [&str; 10] = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"];

pub fn draw(f: &mut Frame, app: &App) {
    let area = f.area();

    // 1. Main Background
    f.render_widget(Block::default().bg(BG_MAIN), area);

    // 2. Vertical Layout: [ Content (Flex), Input (3), Status (1) ]
    let vertical = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Min(1),    // Chat or Terminal or Splash
            Constraint::Length(4), // Input Bar (Height 4 for padding)
            Constraint::Length(1), // Status Footer
        ])
        .split(area);

    let content_area = vertical[0];
    let input_area = vertical[1];
    let status_area = vertical[2];

    // 3. Render Content Area
    // If we only have the system init message, show the "Splash" screen
    // Otherwise show the Chat or Terminal
    if app.messages.len() <= 1 && app.mode == AppMode::Chat {
        draw_splash_screen(f, app, content_area);
    } else {
        match app.mode {
            AppMode::Chat | AppMode::ModelSelector => draw_chat_view(f, app, content_area),
            AppMode::Terminal => draw_terminal_view(f, app, content_area),
        }
    }

    // 4. Render Input Bar (Floating style)
    draw_input_bar(f, app, input_area);

    // 5. Render Status Bar
    draw_status_bar(f, app, status_area);

    // 6. Overlays
    if app.mode == AppMode::ModelSelector {
        draw_model_selector(f, app, area);
    }
}

// --- Views ---

fn draw_splash_screen(f: &mut Frame, _app: &App, area: Rect) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Min(1),
            Constraint::Length(8),  // Logo
            Constraint::Length(1),  // Spacer
            Constraint::Length(10), // Commands
            Constraint::Min(1),
        ])
        .split(area);

    // ASCII Art Logo
    let logo_text = vec![
        Line::from(Span::styled(
            "  ▄▄▄       ▄▄ • ▄▄▄ .▄▄▄  ▄• ▄▌ .▄▄ · ",
            Style::default().fg(FG_PRIMARY).add_modifier(Modifier::BOLD),
        )),
        Line::from(Span::styled(
            "  ▀▄ █·    ▐█ ▀ ▪▀▄.▀·▀▄ █·█▪██▌ ▐█ ▀. ",
            Style::default().fg(FG_PRIMARY).add_modifier(Modifier::BOLD),
        )),
        Line::from(Span::styled(
            "  ▐▀▀▄     ▄█ ▀█▄▐▀▀▪▄▐▀▀▄ █▌▐█▌ ▄▀▀▀█▄",
            Style::default().fg(FG_PRIMARY).add_modifier(Modifier::BOLD),
        )),
        Line::from(Span::styled(
            "  ▐█•█▌    ▐█▄▪▐█▐█▄▄▌▐█•█▌▐█▄█▌ ▐█▄▪▐█",
            Style::default().fg(FG_PRIMARY).add_modifier(Modifier::BOLD),
        )),
        Line::from(Span::styled(
            "  .▀  ▀    ·▀▀▀▀  ▀▀▀ .▀  ▀ ▀▀▀   ▀▀▀▀ ",
            Style::default().fg(FG_PRIMARY).add_modifier(Modifier::BOLD),
        )),
        Line::from(""),
        Line::from(Span::styled(
            "                  v0.1.0                   ",
            Style::default().fg(FG_SECONDARY),
        )),
    ];

    let logo = Paragraph::new(logo_text).alignment(Alignment::Center);
    f.render_widget(logo, chunks[1]);

    // Commands List (Centered)
    let commands_text = vec![
        Line::from(vec![
            Span::styled("Commands         ", Style::default().fg(FG_PRIMARY)),
            Span::styled("ctrl+p", Style::default().fg(ACCENT_ORANGE)),
        ]),
        Line::from(vec![
            Span::styled("List sessions    ", Style::default().fg(FG_PRIMARY)),
            Span::styled("ctrl+l", Style::default().fg(ACCENT_ORANGE)),
        ]),
        Line::from(vec![
            Span::styled("Switch view      ", Style::default().fg(FG_PRIMARY)),
            Span::styled("tab   ", Style::default().fg(ACCENT_ORANGE)),
        ]),
        Line::from(vec![
            Span::styled("Exit             ", Style::default().fg(FG_PRIMARY)),
            Span::styled("ctrl+c", Style::default().fg(ACCENT_ORANGE)),
        ]),
    ];

    // Center the commands horizontally
    let cmd_layout = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(35),
            Constraint::Percentage(30),
            Constraint::Percentage(35),
        ])
        .split(chunks[3]);

    let commands = Paragraph::new(commands_text).alignment(Alignment::Center);
    f.render_widget(commands, cmd_layout[1]);
}

fn draw_chat_view(f: &mut Frame, app: &App, area: Rect) {
    // Add some padding so text isn't glued to the edge
    let area = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Length(2),
            Constraint::Min(1),
            Constraint::Length(2),
        ])
        .split(area)[1];

    let mut lines = vec![];
    let max_width = area.width as usize;

    for msg in &app.messages {
        // Skip the initial system message if we are in chat view to keep it clean
        if matches!(msg.role, MessageRole::System) && msg.content.starts_with("Ready") {
            continue;
        }

        match msg.role {
            MessageRole::System => {
                lines.push(Line::from(Span::styled(
                    format!("  >> {}", msg.content),
                    Style::default().fg(FG_SECONDARY),
                )));
            }
            MessageRole::Thinking => {
                lines.push(Line::from(vec![Span::styled(
                    "  ⚡ Thinking...",
                    Style::default()
                        .fg(FG_SECONDARY)
                        .add_modifier(Modifier::ITALIC),
                )]));
                let rendered = render_markdown(
                    &msg.content,
                    max_width - 4,
                    Style::default()
                        .fg(FG_SECONDARY)
                        .add_modifier(Modifier::ITALIC),
                );
                for line in rendered {
                    let mut spans = vec![Span::raw("    ")];
                    spans.extend(line.spans);
                    lines.push(Line::from(spans));
                }
            }
            _ => {
                let (name, style) = match msg.role {
                    MessageRole::User => (
                        "User",
                        Style::default()
                            .fg(ACCENT_BLUE)
                            .add_modifier(Modifier::BOLD),
                    ),
                    MessageRole::Assistant => (
                        "Agerus",
                        Style::default()
                            .fg(ACCENT_ORANGE)
                            .add_modifier(Modifier::BOLD),
                    ),
                    MessageRole::Error => ("Error", Style::default().fg(Color::Red)),
                    _ => ("System", Style::default().fg(FG_SECONDARY)),
                };

                // Header: Name + Time
                lines.push(Line::from(vec![
                    Span::styled(name, style),
                    Span::styled(
                        format!(" {}", chrono::Local::now().format("%H:%M")),
                        Style::default().fg(FG_SECONDARY),
                    ),
                ]));

                // Content
                if matches!(msg.role, MessageRole::Error) {
                    lines.push(Line::from(Span::styled(
                        &msg.content,
                        Style::default().fg(Color::Red),
                    )));
                } else {
                    let base_style = Style::default().fg(FG_PRIMARY);
                    let rendered = render_markdown(&msg.content, max_width, base_style);
                    lines.extend(rendered);
                }
            }
        }
        lines.push(Line::from("")); // Spacing
    }

    let scroll = if app.chat_stick_to_bottom {
        (lines.len() as u16).saturating_sub(area.height)
    } else {
        app.chat_scroll
    };

    f.render_widget(Paragraph::new(lines).scroll((scroll, 0)), area);
}

fn draw_terminal_view(f: &mut Frame, app: &App, area: Rect) {
    let items: Vec<ListItem> = app
        .terminal_lines
        .iter()
        .map(|l| ListItem::new(Line::from(Span::styled(l, Style::default().fg(FG_PRIMARY)))))
        .collect();

    let mut state = app.term_scroll.clone();
    f.render_stateful_widget(
        List::new(items).block(Block::default().padding(Padding::new(1, 1, 1, 1))),
        area,
        &mut state,
    );
}

fn draw_input_bar(f: &mut Frame, app: &App, area: Rect) {
    // Center the input bar with some margin
    let centered = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(5),
            Constraint::Percentage(90),
            Constraint::Percentage(5),
        ])
        .split(area)[1];

    let block = Block::default()
        .bg(BG_INPUT)
        .padding(Padding::new(2, 2, 1, 1)); // Internal padding

    f.render_widget(block, centered);

    // Draw text inside
    let inner = centered.inner(ratatui::layout::Margin {
        vertical: 1,
        horizontal: 2,
    });

    // If input is empty, show placeholder
    let text = if app.input_buffer.is_empty() {
        Line::from(Span::styled(
            "Ask Agerus anything...",
            Style::default().fg(FG_SECONDARY),
        ))
    } else {
        Line::from(vec![
            Span::styled(&app.input_buffer, Style::default().fg(FG_PRIMARY)),
            Span::styled("█", Style::default().fg(ACCENT_ORANGE)), // Cursor
        ])
    };

    f.render_widget(Paragraph::new(text), inner);

    // Optional: Draw a thin colored line on the left to match the screenshot style
    let decoration_area = Rect {
        x: centered.x,
        y: centered.y + 1,
        width: 1,
        height: 2,
    };
    f.render_widget(Block::default().bg(ACCENT_BLUE), decoration_area);
}

fn draw_status_bar(f: &mut Frame, app: &App, area: Rect) {
    let workspace_name = app
        .config
        .workspace_path
        .file_name()
        .unwrap_or_default()
        .to_string_lossy();

    let mode_str = match app.mode {
        AppMode::Chat => "CHAT",
        AppMode::Terminal => "TERM",
        AppMode::ModelSelector => "MENU",
    };

    let spinner = if app.is_processing {
        SPINNER[app.spinner_frame % SPINNER.len()]
    } else {
        " "
    };

    let left_text = vec![
        Span::styled(
            format!(" agerus v0.1.0 "),
            Style::default().fg(FG_SECONDARY).bg(Color::Rgb(20, 20, 20)),
        ),
        Span::styled(
            format!(" {} ", workspace_name),
            Style::default().fg(FG_PRIMARY),
        ),
        Span::styled(
            format!(" {} ", mode_str),
            Style::default()
                .fg(BG_MAIN)
                .bg(ACCENT_BLUE)
                .add_modifier(Modifier::BOLD),
        ),
    ];

    let right_text = vec![
        Span::styled(format!(" {} ", spinner), Style::default().fg(ACCENT_ORANGE)),
        Span::styled(" tab: switch view ", Style::default().fg(FG_SECONDARY)),
        Span::styled(" ctrl+p: model ", Style::default().fg(FG_SECONDARY)),
    ];

    let layout = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Min(0), Constraint::Min(0)])
        .split(area);

    f.render_widget(
        Paragraph::new(Line::from(left_text)).alignment(Alignment::Left),
        layout[0],
    );
    f.render_widget(
        Paragraph::new(Line::from(right_text)).alignment(Alignment::Right),
        layout[1],
    );
}

fn draw_model_selector(f: &mut Frame, app: &App, area: Rect) {
    let block = Block::default()
        .title(" Select Model ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(ACCENT_BLUE))
        .bg(BG_MAIN);

    let area = centered_rect(50, 40, area);
    f.render_widget(Clear, area);
    f.render_widget(block.clone(), area);

    let inner = block.inner(area);

    let items: Vec<ListItem> = app
        .available_models
        .iter()
        .map(|m| {
            let is_current = *m == app.config.model;
            let style = if is_current {
                Style::default()
                    .fg(ACCENT_ORANGE)
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default().fg(FG_PRIMARY)
            };

            let prefix = if is_current { "● " } else { "  " };
            ListItem::new(format!("{}{}", prefix, m)).style(style)
        })
        .collect();

    let list = List::new(items)
        .highlight_style(Style::default().bg(Color::Rgb(20, 20, 20)))
        .highlight_symbol(" ");

    let mut state = app.model_list_state.clone();
    f.render_stateful_widget(list, inner, &mut state);
}

fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -> Rect {
    let popup_layout = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage((100 - percent_y) / 2),
            Constraint::Percentage(percent_y),
            Constraint::Percentage((100 - percent_y) / 2),
        ])
        .split(r);

    Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage((100 - percent_x) / 2),
            Constraint::Percentage(percent_x),
            Constraint::Percentage((100 - percent_x) / 2),
        ])
        .split(popup_layout[1])[1]
}
